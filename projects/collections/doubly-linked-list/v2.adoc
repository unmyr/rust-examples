ifndef::leveloffset[]
:toc: left
:toclevels: 3
:icons: font
endif::[]

== v2: Add pop_back

=== v2.1: List requires Clone trait.

[source,rust]
.src/v2.rs
----
use std::rc::Rc;
use std::rc::Weak;
use std::cell::RefCell;
use std::fmt;
use std::fmt::Debug;

pub struct Node<T: Debug> {
    value: T,
    prev: Option<Weak<RefCell<Node<T>>>>,
    next: Option<Rc<RefCell<Node<T>>>>,
}

#[derive(Default)]
pub struct List<T: Debug> {
    head: Option<Rc<RefCell<Node<T>>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(v: T) -> Node<T> {
        Node { value: v, next: None, prev: None }
    }
}

impl<T: Debug> Drop for List<T> {
    fn drop(&mut self) {
        println!("> Dropping: List");
    }
}

impl<T: Debug> Drop for Node<T> {
    fn drop(&mut self) {
        println!("> Dropping: Node {:?}", self.value);
    }
}

impl<T: Debug + Clone> List<T> {
    pub fn push_back(&mut self, v: T) {
        let mut node_new = Node::new(v);
        let mut cur: Rc<RefCell<Node<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            self.head = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            cur = Rc::clone(next);
        }
        node_new.prev = Some(Rc::downgrade(&cur));

        cur.borrow_mut().next = Some(
            Rc::new(RefCell::new(node_new))
        );
    }

    pub fn pop_back(&mut self) -> Option<T> {
        let mut cur: Rc<RefCell<Node<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            return None;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            cur = Rc::clone(next);
        }

        if let Some(prev) = &Rc::clone(&cur).borrow_mut().prev {
            prev.upgrade().unwrap().borrow_mut().next = None;
        } else {
            self.head = None;
        }

        assert_eq!(Rc::strong_count(&cur), 1);
        assert_eq!(Rc::weak_count(&cur), 0);
        let result: T;
        result = Rc::clone(&cur).borrow().value.clone();
        Some(result)
    }
}

impl<T: Debug> fmt::Display for Node<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match (self.prev.as_ref(), self.next.as_ref()) {
            (None, None) => {
                write!(f, "Node({:?}, Nil, Nil)", self.value)
            },
            (Some(prev), None) => {
                write!(
                    f, "Node({:?}, {:?}, Nil)",
                    self.value,
                    Rc::clone(&prev.upgrade().unwrap()).borrow().value
                )
            },
            (None, Some(next)) => {
                write!(
                    f, "Node({:?}, Nil, {:?}), {}",
                    self.value, next.borrow().value, next.borrow()
                )
            },
            (Some(prev), Some(next)) => {
                write!(
                    f, "Node({:?}, {:?}, {:?}), {}",
                    self.value,
                    Rc::clone(&prev.upgrade().unwrap()).borrow().value,
                    next.borrow().value,
                    next.borrow()
                )
            }
        }
    }
}

impl<T: Debug> fmt::Display for List<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.head {
            None => write!(f, "List[]"),
            Some(ref head) => {
                write!(f, "List[{}]", head.borrow())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::v2::List;

    #[test]
    fn test_push_back_u8() {
        let mut list: List<u8> = Default::default();
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);
        assert_eq!(list.pop_back(), Some(3));
        assert_eq!(list.pop_back(), Some(2));
        assert_eq!(list.pop_back(), Some(1));
        assert_eq!(list.pop_back(), None);
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);
        assert_eq!(list.pop_back(), Some(3));
        assert_eq!(list.pop_back(), Some(2));
        assert_eq!(list.pop_back(), Some(1));
        assert_eq!(list.pop_back(), None);
    }
}
----

[source,rust]
.src/bin/db_list_v2.rs
----
use list::v2::List;

fn main() {
    let mut list: List<u8> = Default::default();
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);
    println!("{}", list);
    assert_eq!(list.pop_back(), Some(3));
    println!("{}", list);
    assert_eq!(list.pop_back(), Some(2));
    println!("{}", list);
    assert_eq!(list.pop_back(), Some(1));
    println!("{}", list);
    assert_eq!(list.pop_back(), None);
}
----

[source,console]
----
$ cargo run --bin db_list_v2
   Compiling doubly-linked-list v0.1.0 (/home/guest/tmp_rust/rust-examples/projects/collections/doubly-linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 3.09s
     Running `/home/guest/tmp_rust/rust-examples/projects/collections/target/debug/db_list_v2`
List[Node(1, Nil, 2), Node(2, 1, 3), Node(3, 2, Nil)]
> Dropping: Node 3
List[Node(1, Nil, 2), Node(2, 1, Nil)]
> Dropping: Node 2
List[Node(1, Nil, Nil)]
> Dropping: Node 1
List[]
> Dropping: List
----

=== v2.2: could not compile

[source,diff]
----
@@ -33,7 +33,7 @@ impl<T: Debug> Drop for Node<T> {
     }
 }

-impl<T: Debug + Clone> List<T> {
+impl<T: Debug> List<T> {
     pub fn push_back(&mut self, v: T) {
         let mut node_new = Node::new(v);
         let mut cur: Rc<RefCell<Node<T>>>;
@@ -74,9 +74,8 @@ impl<T: Debug + Clone> List<T> {

         assert_eq!(Rc::strong_count(&cur), 1);
         assert_eq!(Rc::weak_count(&cur), 0);
-        let result: T;
-        result = Rc::clone(&cur).borrow().value.clone();
-        Some(result)
+        let last: Node<T> = Rc::try_unwrap(cur).ok().unwrap().into_inner();
+        Some(last.value)
     }
 }
----

[source,console]
----
$ cargo run --bin db_list_v2
   Compiling doubly-linked-list v0.1.0 (.../doubly-linked-list)
error[E0509]: cannot move out of type `v2::Node<T>`, which implements the `Drop` trait
  --> doubly-linked-list/src/v2.rs:78:14
   |
78 |         Some(last.value)
   |              ^^^^^^^^^^
   |              |
   |              cannot move out of here
   |              move occurs because `last.value` has type `T`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0509`.
error: could not compile `doubly-linked-list` due to previous error
----

=== v2.3: Remove drop traits

Remove the implementation of Drop for Node<T> to remove the Clone trait from pop_back().

[source,diff]
----
@@ -21,19 +21,7 @@ impl<T: Debug> Node<T> {
     }
 }

-impl<T: Debug> Drop for List<T> {
-    fn drop(&mut self) {
-        println!("> Dropping: List");
-    }
-}
-
-impl<T: Debug> Drop for Node<T> {
-    fn drop(&mut self) {
-        println!("> Dropping: Node {:?}", self.value);
-    }
-}
-
-impl<T: Debug + Clone> List<T> {
+impl<T: Debug> List<T> {
     pub fn push_back(&mut self, v: T) {
         let mut node_new = Node::new(v);
         let mut cur: Rc<RefCell<Node<T>>>;
@@ -74,9 +62,8 @@ impl<T: Debug + Clone> List<T> {

         assert_eq!(Rc::strong_count(&cur), 1);
         assert_eq!(Rc::weak_count(&cur), 0);
-        let result: T;
-        result = Rc::clone(&cur).borrow().value.clone();
-        Some(result)
+        let last: Node<T> = Rc::try_unwrap(cur).ok().unwrap().into_inner();
+        Some(last.value)
     }
 }
----

[source,rust]
.src/v2.rs
----
use std::rc::Rc;
use std::rc::Weak;
use std::cell::RefCell;
use std::fmt;
use std::fmt::Debug;

pub struct Node<T: Debug> {
    value: T,
    prev: Option<Weak<RefCell<Node<T>>>>,
    next: Option<Rc<RefCell<Node<T>>>>,
}

#[derive(Default)]
pub struct List<T: Debug> {
    head: Option<Rc<RefCell<Node<T>>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(v: T) -> Node<T> {
        Node { value: v, next: None, prev: None }
    }
}

impl<T: Debug> List<T> {
    pub fn push_back(&mut self, v: T) {
        let mut node_new = Node::new(v);
        let mut cur: Rc<RefCell<Node<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            self.head = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            cur = Rc::clone(next);
        }
        node_new.prev = Some(Rc::downgrade(&cur));

        cur.borrow_mut().next = Some(
            Rc::new(RefCell::new(node_new))
        );
    }

    pub fn pop_back(&mut self) -> Option<T> {
        let mut cur: Rc<RefCell<Node<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            return None;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            cur = Rc::clone(next);
        }

        if let Some(prev) = &Rc::clone(&cur).borrow_mut().prev {
            prev.upgrade().unwrap().borrow_mut().next = None;
        } else {
            self.head = None;
        }

        assert_eq!(Rc::strong_count(&cur), 1);
        assert_eq!(Rc::weak_count(&cur), 0);
        let last: Node<T> = Rc::try_unwrap(cur).ok().unwrap().into_inner();
        Some(last.value)
    }
}

impl<T: Debug> fmt::Display for Node<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match (self.prev.as_ref(), self.next.as_ref()) {
            (None, None) => {
                write!(f, "Node({:?}, Nil, Nil)", self.value)
            },
            (Some(prev), None) => {
                write!(
                    f, "Node({:?}, {:?}, Nil)",
                    self.value,
                    Rc::clone(&prev.upgrade().unwrap()).borrow().value
                )
            },
            (None, Some(next)) => {
                write!(
                    f, "Node({:?}, Nil, {:?}), {}",
                    self.value, next.borrow().value, next.borrow()
                )
            },
            (Some(prev), Some(next)) => {
                write!(
                    f, "Node({:?}, {:?}, {:?}), {}",
                    self.value,
                    Rc::clone(&prev.upgrade().unwrap()).borrow().value,
                    next.borrow().value,
                    next.borrow()
                )
            }
        }
    }
}

impl<T: Debug> fmt::Display for List<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.head {
            None => write!(f, "List[]"),
            Some(ref head) => {
                write!(f, "List[{}]", head.borrow())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::v2::List;

    #[test]
    fn test_push_back_u8() {
        let mut list: List<u8> = Default::default();
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);
        assert_eq!(list.pop_back(), Some(3));
        assert_eq!(list.pop_back(), Some(2));
        assert_eq!(list.pop_back(), Some(1));
        assert_eq!(list.pop_back(), None);
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);
        assert_eq!(list.pop_back(), Some(3));
        assert_eq!(list.pop_back(), Some(2));
        assert_eq!(list.pop_back(), Some(1));
        assert_eq!(list.pop_back(), None);
    }
}
----

[source,console]
.Results
----
$ cargo run --bin db_list_v2
   Compiling doubly-linked-list v0.1.0 (.../doubly-linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 3.71s
     Running `.../target/debug/db_list_v2`
List[Node(1, Nil, 2), Node(2, 1, 3), Node(3, 2, Nil)]
List[Node(1, Nil, 2), Node(2, 1, Nil)]
List[Node(1, Nil, Nil)]
List[]
----

=== v2.4: Revert the drop trait back 
Revert the drop trait back by using `RefCell<Option<T>>`.

[source,diff]
.src/v2.rs
----
@@ -5,7 +5,7 @@ use std::fmt;
 use std::fmt::Debug;

 pub struct Node<T: Debug> {
-    value: T,
+    value: RefCell<Option<T>>,
     prev: Option<Weak<RefCell<Node<T>>>>,
     next: Option<Rc<RefCell<Node<T>>>>,
 }
@@ -17,7 +17,19 @@ pub struct List<T: Debug> {

 impl<T: Debug> Node<T> {
     pub fn new(v: T) -> Node<T> {
-        Node { value: v, next: None, prev: None }
+        Node { value: RefCell::new(Some(v)), next: None, prev: None }
+    }
+}
+
+impl<T: Debug> Drop for List<T> {
+    fn drop(&mut self) {
+        println!("> Dropping: List");
+    }
+}
+
+impl<T: Debug> Drop for Node<T> {
+    fn drop(&mut self) {
+        println!("> Dropping: Node {:?}", self.value);
     }
 }

@@ -63,7 +75,7 @@ impl<T: Debug> List<T> {
         assert_eq!(Rc::strong_count(&cur), 1);
         assert_eq!(Rc::weak_count(&cur), 0);
         let last: Node<T> = Rc::try_unwrap(cur).ok().unwrap().into_inner();
-        Some(last.value)
+        last.value.take()
     }
 }
----

[source,console]
.Results
----
$ cargo run --bin=db_list_v2
   Compiling doubly-linked-list v0.1.0 (.../doubly-linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 2.52s
     Running `.../target/debug/db_list_v2`
List[Node(RefCell { value: Some(1) }, Nil, RefCell { value: Some(2) }), Node(RefCell { value: Some(2) }, RefCell { value: Some(1) }, RefCell { value: Some(3) }), Node(RefCell { value: Some(3) }, RefCell { value: Some(2) }, Nil)]
> Dropping: Node RefCell { value: None }
List[Node(RefCell { value: Some(1) }, Nil, RefCell { value: Some(2) }), Node(RefCell { value: Some(2) }, RefCell { value: Some(1) }, Nil)]
> Dropping: Node RefCell { value: None }
List[Node(RefCell { value: Some(1) }, Nil, Nil)]
> Dropping: Node RefCell { value: None }
List[]
> Dropping: List
----

=== v2.5: Implement Iterator trait

[source,diff]
----
@@ -101,6 +101,28 @@ impl<T: Debug> List<T> {
         let last: Node<T> = Rc::try_unwrap(cur).ok().unwrap().into_inner();
         last.value.take()
     }
+
+    /// # Examples
+    ///
+    /// ```
+    /// use list::v2::List;
+    /// let mut list: List<u8> = Default::default();
+    /// list.push_back(1);
+    /// list.push_back(2);
+    /// let mut iter = list.iter();
+    /// assert_eq!(iter.next(), Some(1));
+    /// assert_eq!(iter.next(), Some(2));
+    /// assert_eq!(iter.next(), None);
+    /// ```
+    pub fn iter(&self) -> ListIterator<T> {
+        if let Some(ref head) = self.head {
+            ListIterator {
+                cur: Some(Rc::downgrade(&Rc::clone(head)))
+            }
+        } else {
+            ListIterator { cur: None }
+        }
+    }
 }

 impl<T: Debug> Drop for List<T> {
@@ -120,6 +142,33 @@ impl<T: Debug> fmt::Display for List<T> {
     }
 }

+pub struct ListIterator<T: Debug> {
+    cur: Option<Weak<RefCell<Node<T>>>>
+}
+
+impl<T: Clone + Debug> Iterator for ListIterator<T> {
+    type Item = T;
+    fn next(&mut self) -> Option<Self::Item> {
+        let cur_weak = match self.cur {
+            Some(ref cur_weak) => cur_weak,
+            None => return None,
+        };
+
+        let cur_strong = match cur_weak.upgrade() {
+            Some(cur_strong) => cur_strong,
+            None => return None,
+        };
+
+        let cur_val = cur_strong.borrow().value.borrow().clone();
+        if let Some(ref next) = cur_strong.borrow().next {
+            self.cur = Some(Rc::downgrade(next))
+        } else {
+            self.cur = None;
+        }
+        cur_val
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::List;
----

[source,rust]
.src/v2.rs
----
use std::rc::{Rc, Weak};
use std::cell::RefCell;
use std::fmt::{self, Debug};

pub struct Node<T: Debug> {
    value: RefCell<Option<T>>,
    prev: Option<Weak<RefCell<Node<T>>>>,
    next: Option<Rc<RefCell<Node<T>>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(v: T) -> Node<T> {
        Node { value: RefCell::new(Some(v)), next: None, prev: None }
    }
}

impl<T: Debug> Drop for Node<T> {
    fn drop(&mut self) {
        println!("> Dropping: Node {:?}", self.value);
    }
}

impl<T: Debug> fmt::Display for Node<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match (self.prev.as_ref(), self.next.as_ref()) {
            (None, None) => {
                write!(f, "Node({:?}, Nil, Nil)", self.value)
            },
            (Some(prev), None) => {
                write!(
                    f, "Node({:?}, {:?}, Nil)",
                    self.value,
                    Rc::clone(&prev.upgrade().unwrap()).borrow().value
                )
            },
            (None, Some(next)) => {
                write!(
                    f, "Node({:?}, Nil, {:?}), {}",
                    self.value, next.borrow().value, next.borrow()
                )
            },
            (Some(prev), Some(next)) => {
                write!(
                    f, "Node({:?}, {:?}, {:?}), {}",
                    self.value,
                    Rc::clone(&prev.upgrade().unwrap()).borrow().value,
                    next.borrow().value,
                    next.borrow()
                )
            }
        }
    }
}

#[derive(Default)]
pub struct List<T: Debug> {
    head: Option<Rc<RefCell<Node<T>>>>,
}

impl<T: Debug> List<T> {
    pub fn push_back(&mut self, v: T) {
        let mut node_new = Node::new(v);
        let mut cur: Rc<RefCell<Node<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            self.head = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            cur = Rc::clone(next);
        }
        node_new.prev = Some(Rc::downgrade(&cur));

        cur.borrow_mut().next = Some(
            Rc::new(RefCell::new(node_new))
        );
    }

    pub fn pop_back(&mut self) -> Option<T> {
        let mut cur: Rc<RefCell<Node<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            return None;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            cur = Rc::clone(next);
        }

        if let Some(prev) = &Rc::clone(&cur).borrow_mut().prev {
            prev.upgrade().unwrap().borrow_mut().next = None;
        } else {
            self.head = None;
        }

        assert_eq!(Rc::strong_count(&cur), 1);
        assert_eq!(Rc::weak_count(&cur), 0);
        let last: Node<T> = Rc::try_unwrap(cur).ok().unwrap().into_inner();
        last.value.take()
    }

    /// # Examples
    ///
    /// ```
    /// use list::v2::List;
    /// let mut list: List<u8> = Default::default();
    /// list.push_back(1);
    /// list.push_back(2);
    /// let mut iter = list.iter();
    /// assert_eq!(iter.next(), Some(1));
    /// assert_eq!(iter.next(), Some(2));
    /// assert_eq!(iter.next(), None);
    /// ```
    pub fn iter(&self) -> ListIterator<T> {
        if let Some(ref head) = self.head {
            ListIterator {
                cur: Some(Rc::downgrade(&Rc::clone(head)))
            }
        } else {
            ListIterator { cur: None }
        }
    }
}

impl<T: Debug> Drop for List<T> {
    fn drop(&mut self) {
        println!("> Dropping: List");
    }
}

impl<T: Debug> fmt::Display for List<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.head {
            None => write!(f, "List[]"),
            Some(ref head) => {
                write!(f, "List[{}]", head.borrow())
            }
        }
    }
}

pub struct ListIterator<T: Debug> {
    cur: Option<Weak<RefCell<Node<T>>>>
}

impl<T: Clone + Debug> Iterator for ListIterator<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        let cur_weak = match self.cur {
            Some(ref cur_weak) => cur_weak,
            None => return None,
        };

        let cur_strong = match cur_weak.upgrade() {
            Some(cur_strong) => cur_strong,
            None => return None,
        };

        let cur_val = cur_strong.borrow().value.borrow().clone();
        if let Some(ref next) = cur_strong.borrow().next {
            self.cur = Some(Rc::downgrade(next))
        } else {
            self.cur = None;
        }
        cur_val
    }
}

#[cfg(test)]
mod tests {
    use super::List;

    #[test]
    fn test_push_back_u8() {
        let mut list: List<u8> = Default::default();
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);
        assert_eq!(list.pop_back(), Some(3));
        assert_eq!(list.pop_back(), Some(2));
        assert_eq!(list.pop_back(), Some(1));
        assert_eq!(list.pop_back(), None);
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);
        assert_eq!(list.pop_back(), Some(3));
        assert_eq!(list.pop_back(), Some(2));
        assert_eq!(list.pop_back(), Some(1));
        assert_eq!(list.pop_back(), None);
    }
}
----
