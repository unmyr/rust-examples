== v1

=== v1.1 There is a memory leak in this code

This code does not free the Node objects, resulting in a memory leak.

[source,rust]
.src/v1.rs
----
use std::rc::Rc;
use std::cell::RefCell;
use std::fmt;
use std::fmt::Debug;

pub struct Node<T: Debug> {
    value: T,
    prev: Option<Rc<RefCell<Node<T>>>>,
    next: Option<Rc<RefCell<Node<T>>>>,
}

#[derive(Default)]
pub struct List<T: Debug> {
    head: Option<Rc<RefCell<Node<T>>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(v: T) -> Node<T> {
        Node { value: v, next: None, prev: None }
    }
}

impl<T: Debug> Drop for List<T> {
    fn drop(&mut self) {
        println!("> Dropping: List");
    }
}

impl<T: Debug> Drop for Node<T> {
    fn drop(&mut self) {
        println!("> Dropping: Node {:?}", self.value);
    }
}

impl<T: Debug> List<T> {
    pub fn push_back(&mut self, v: T) {
        let mut node_new = Node::new(v);
        let mut cur: Rc<RefCell<Node<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            self.head = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            cur = Rc::clone(next);
        }
        node_new.prev = Some(Rc::clone(&cur));

        cur.borrow_mut().next = Some(
            Rc::new(RefCell::new(node_new))
        );
    }
}

impl<T: Debug> fmt::Display for Node<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match (self.prev.as_ref(), self.next.as_ref()) {
            (None, None) => {
                write!(f, "Node({:?}, Nil, Nil)", self.value)
            },
            (Some(prev), None) => {
                write!(
                    f, "Node({:?}, {:?}, Nil)",
                    self.value, prev.borrow().value
                )
            },
            (None, Some(next)) => {
                write!(
                    f, "Node({:?}, Nil, {:?}), {}",
                    self.value, next.borrow().value, next.borrow()
                )
            },
            (Some(prev), Some(next)) => {
                write!(
                    f, "Node({:?}, {:?}, {:?}), {}",
                    self.value, prev.borrow().value, next.borrow().value, next.borrow()
                )
            }
        }
    }
}

impl<T: Debug> fmt::Display for List<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.head {
            None => write!(f, "List[]"),
            Some(ref head) => {
                write!(f, "List[{}]", head.borrow())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::v1::List;

    #[test]
    fn test_push_back_u8() {
        let mut list: List<u8> = Default::default();
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);
    }
}
----

[source,rust]
.src/bin/db_list_v1.rs
----
use list::v1::List;

fn main() {
    let mut list: List<u8> = Default::default();
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);
    println!("{}", list);
}
----

[source,console]
.Results
----
$ cargo run --bin db_list_v1
   Compiling doubly-linked-list v0.1.0 (.../doubly-linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 1.41s
     Running `.../target/debug/db_list_v1`
List[Node(1, Nil, 2), Node(2, 1, 3), Node(3, 2, Nil)]
> Dropping: List
----

=== v1.2: Fix memory leaks

[source,diff]
.src/v1.rs
----
@@ -1,11 +1,12 @@
 use std::rc::Rc;
+use std::rc::Weak;
 use std::cell::RefCell;
 use std::fmt;
 use std::fmt::Debug;

 pub struct Node<T: Debug> {
     value: T,
-    prev: Option<Rc<RefCell<Node<T>>>>,
+    prev: Option<Weak<RefCell<Node<T>>>>,
     next: Option<Rc<RefCell<Node<T>>>>,
 }

@@ -46,7 +47,7 @@ impl<T: Debug> List<T> {
         while let Some(ref next) = Rc::clone(&cur).borrow().next {
             cur = Rc::clone(next);
         }
-        node_new.prev = Some(Rc::clone(&cur));
+        node_new.prev = Some(Rc::downgrade(&cur));

         cur.borrow_mut().next = Some(
             Rc::new(RefCell::new(node_new))
@@ -63,7 +64,8 @@ impl<T: Debug> fmt::Display for Node<T> {
             (Some(prev), None) => {
                 write!(
                     f, "Node({:?}, {:?}, Nil)",
-                    self.value, prev.borrow().value
+                    self.value,
+                    Rc::clone(&prev.upgrade().unwrap()).borrow().value
                 )
             },
             (None, Some(next)) => {
@@ -75,7 +77,10 @@ impl<T: Debug> fmt::Display for Node<T> {
             (Some(prev), Some(next)) => {
                 write!(
                     f, "Node({:?}, {:?}, {:?}), {}",
-                    self.value, prev.borrow().value, next.borrow().value, next.borrow()
+                    self.value,
+                    Rc::clone(&prev.upgrade().unwrap()).borrow().value,
+                    next.borrow().value,
+                    next.borrow()
                 )
             }
         }
----

[source,rust]
.src/v1.rs
----
use std::rc::Rc;
use std::rc::Weak;
use std::cell::RefCell;
use std::fmt;
use std::fmt::Debug;

pub struct Node<T: Debug> {
    value: T,
    prev: Option<Weak<RefCell<Node<T>>>>,
    next: Option<Rc<RefCell<Node<T>>>>,
}

#[derive(Default)]
pub struct List<T: Debug> {
    head: Option<Rc<RefCell<Node<T>>>>,
}

impl<T: Debug> Node<T> {
    pub fn new(v: T) -> Node<T> {
        Node { value: v, next: None, prev: None }
    }
}

impl<T: Debug> Drop for List<T> {
    fn drop(&mut self) {
        println!("> Dropping: List");
    }
}

impl<T: Debug> Drop for Node<T> {
    fn drop(&mut self) {
        println!("> Dropping: Node {:?}", self.value);
    }
}

impl<T: Debug> List<T> {
    pub fn push_back(&mut self, v: T) {
        let mut node_new = Node::new(v);
        let mut cur: Rc<RefCell<Node<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            self.head = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            cur = Rc::clone(next);
        }
        node_new.prev = Some(Rc::downgrade(&cur));

        cur.borrow_mut().next = Some(
            Rc::new(RefCell::new(node_new))
        );
    }
}

impl<T: Debug> fmt::Display for Node<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match (self.prev.as_ref(), self.next.as_ref()) {
            (None, None) => {
                write!(f, "Node({:?}, Nil, Nil)", self.value)
            },
            (Some(prev), None) => {
                write!(
                    f, "Node({:?}, {:?}, Nil)",
                    self.value,
                    Rc::clone(&prev.upgrade().unwrap()).borrow().value
                )
            },
            (None, Some(next)) => {
                write!(
                    f, "Node({:?}, Nil, {:?}), {}",
                    self.value, next.borrow().value, next.borrow()
                )
            },
            (Some(prev), Some(next)) => {
                write!(
                    f, "Node({:?}, {:?}, {:?}), {}",
                    self.value,
                    Rc::clone(&prev.upgrade().unwrap()).borrow().value,
                    next.borrow().value,
                    next.borrow()
                )
            }
        }
    }
}

impl<T: Debug> fmt::Display for List<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.head {
            None => write!(f, "List[]"),
            Some(ref head) => {
                write!(f, "List[{}]", head.borrow())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::v1::List;

    #[test]
    fn test_push_back_u8() {
        let mut list: List<u8> = Default::default();
        list.push_back(1);
        list.push_back(2);
        list.push_back(3);
    }
}
----

[source,console]
.Results
----
$ cargo run --bin db_list_v1
   Compiling doubly-linked-list v0.1.0 (.../doubly-linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 2.05s
     Running `.../target/debug/db_list_v1`
List[Node(1, Nil, 2), Node(2, 1, 3), Node(3, 2, Nil)]
> Dropping: List
> Dropping: Node 1
> Dropping: Node 2
> Dropping: Node 3
----
