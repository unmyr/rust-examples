ifndef::leveloffset[]
:toc: left
:toclevels: 3
:icons: font
endif::[]

=== Set up a new project
. Set up a new project, and go to the projects directory.
+
[source,console]
----
$ cargo new --lib singly-linked-list
     Created library `singly-linked-list` package
$ cd singly-linked-list/
----

=== Codes

==== v0: Cannot compile

[source,rust]
.src/lib.rs
----
use std::fmt;
use std::fmt::Debug;
use std::rc::Rc;
use std::cell::RefCell;

pub struct ListNode<T: Debug> {
    value: T,
    next: Option<Rc<RefCell<ListNode<T>>>>,
}

pub struct SinglyLinkedList<T: Debug> {
    head: Option<Rc<RefCell<ListNode<T>>>>,
}

impl<T: Debug> fmt::Display for ListNode<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.next {
            None => write!(f, "ListNode({:?},Nil)", self.value),
            Some(ref next) => {
                write!(f, "ListNode({:?},{})", self.value, next.borrow())
            }
        }
    }
}

impl<T: Debug> fmt::Display for SinglyLinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.head {
            None => write!(f, "SinglyLinkedList(Nil)"),
            Some(ref head) => {
                write!(f, "SinglyLinkedList({})", head.borrow())
            }
        }
    }
}

impl<T: Debug> ListNode<T> {
    pub fn new(v: T) -> ListNode<T> {
        ListNode { value: v, next: None }
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    pub fn new() -> SinglyLinkedList<T> {
        SinglyLinkedList {
            head: None,
        }
    }

    pub fn push_back(&mut self, v: T) {
        let node_new = ListNode::new(v);

        let mut cur: Option<Rc<RefCell<ListNode<T>>>>;
        if let Some(ref head) = self.head {
            cur = Some(Rc::clone(head));
        } else {
            self.head = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        loop {
            let cur_cloned = match cur {
                None => break,
                Some(ref n) => Rc::clone(n)
            };
            cur = match cur_cloned.borrow().next {
                Some(ref next) => Some(Rc::clone(next)),
                None => {
                    cur_cloned.borrow_mut().next = Some(Rc::new(RefCell::new(node_new)));  //<1>
                    return;
                }
            };
        }
    }
}
----
<1> BorrowMutError

[source,rust]
.src/main.rs
----
use list::SinglyLinkedList;

fn main() {
    let mut list = SinglyLinkedList::new();
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);
    println!("{}", list);
}
----

[source,console]
----
$ cargo run
   Compiling singly-linked-list v0.1.0 (.../singly-linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 2.23s
     Running `/home/guest/tmp_rust/rust-examples/projects/collections/target/debug/singly-linked-list`
thread 'main' panicked at 'already borrowed: BorrowMutError', .../singly-linked-list/src/lib.rs:68:32
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
----

==== v1: Using unsafe

[source,rust]
.src/lib.rs
----
use std::fmt;
use std::fmt::Debug;
use std::rc::Rc;
use std::cell::RefCell;

pub struct ListNode<T: Debug> {
    value: T,
    next: Option<Rc<RefCell<ListNode<T>>>>,
}

pub struct SinglyLinkedList<T: Debug> {
    head: Option<Rc<RefCell<ListNode<T>>>>,
}

impl<T: Debug> fmt::Display for ListNode<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.next {
            None => write!(f, "ListNode({:?},Nil)", self.value),
            Some(ref next) => {
                write!(f, "ListNode({:?},{})", self.value, next.borrow())
            }
        }
    }
}

impl<T: Debug> fmt::Display for SinglyLinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.head {
            None => write!(f, "SinglyLinkedList(Nil)"),
            Some(ref head) => {
                write!(f, "SinglyLinkedList({})", head.borrow())
            }
        }
    }
}
impl<T: Debug> ListNode<T> {
    pub fn new(v: T) -> ListNode<T> {
        ListNode { value: v, next: None }
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    pub fn new() -> SinglyLinkedList<T> {
        SinglyLinkedList {
            head: None,
        }
    }

    pub fn push_back(&mut self, v: T) {
        let node_new = ListNode::new(v);

        let mut cur: Option<Rc<RefCell<ListNode<T>>>>;
        if let Some(ref head) = self.head {
            cur = Some(Rc::clone(head));
        } else {
            self.head = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        loop {
            let cur_cloned = match cur {
                None => break,
                Some(ref n) => Rc::clone(n)
            };
            cur = match cur_cloned.borrow().next {
                Some(ref next) => Some(Rc::clone(next)),
                None => {
                    unsafe {
                        (*cur_cloned.as_ptr()).next = Some(
                            Rc::new(
                                RefCell::new(node_new)
                            )
                        );
                    }
                    return;
                }
            };
        }
    }
}
----

[source,rust]
.src/main.rs
----
use list::SinglyLinkedList;

fn main() {
    let mut list = SinglyLinkedList::new();
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);
    println!("{}", list);
}
----

[source,console]
.Results
----
$ cargo run
   Compiling singly-linked-list v0.1.0 (.../singly-linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 2.33s
     Running `.../singly-linked-list`
SinglyLinkedList(ListNode(1,ListNode(2,ListNode(3,Nil))))
----

==== v2: Remove unsafe

Using a Infinite loops expression.

[source,rust]
.src/lib.rs
----
use std::fmt;
use std::fmt::Debug;
use std::rc::Rc;
use std::cell::RefCell;

pub struct ListNode<T: Debug> {
    value: T,
    next: Option<Rc<RefCell<ListNode<T>>>>,
}

pub struct SinglyLinkedList<T: Debug> {
    head: Option<Rc<RefCell<ListNode<T>>>>,
}

impl<T: Debug> fmt::Display for ListNode<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.next {
            None => write!(f, "ListNode({:?},Nil)", self.value),
            Some(ref next) => {
                write!(f, "ListNode({:?},{})", self.value, next.borrow())
            }
        }
    }
}

impl<T: Debug> fmt::Display for SinglyLinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.head {
            None => write!(f, "SinglyLinkedList(Nil)"),
            Some(ref head) => {
                write!(f, "SinglyLinkedList({})", head.borrow())
            }
        }
    }
}
impl<T: Debug> ListNode<T> {
    pub fn new(v: T) -> ListNode<T> {
        ListNode { value: v, next: None }
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    pub fn new() -> SinglyLinkedList<T> {
        SinglyLinkedList {
            head: None,
        }
    }

    pub fn push_back(&mut self, v: T) {
        let node_new = ListNode::new(v);
        let mut cur: Rc<RefCell<ListNode<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);  //<1>
        } else {
            self.head = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        loop {
            if let Some(ref next) = Rc::clone(&cur).borrow().next {  //<1>
                cur = Rc::clone(next);  //<1>
                continue;
            } // <2>

            cur.borrow_mut().next = Some(
                Rc::new(RefCell::new(node_new))
            );
            return;
        }
    }
}
----
<1> Use `Rc::clone()` to avoid move the pointer.
<2> The `cur` is still borrowed in the if-else and `match` block.

[source,rust]
.src/main.rs
----
use list::SinglyLinkedList;

fn main() {
    let mut list = SinglyLinkedList::new();
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);
    println!("{}", list);
}
----

[source,console]
.Results
----
$ cargo run
   Compiling singly-linked-list v0.1.0 (.../singly-linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 2.29s
     Running `.../target/debug/singly-linked-list`
SinglyLinkedList(ListNode(1,ListNode(2,ListNode(3,Nil))))
----

==== v3: Replace to `while let` expression.

[source,diff]
.src/lib.rs
----
@@ -56,16 +56,12 @@ impl<T: Debug> SinglyLinkedList<T> {
             return;
         };

-        loop {
-            if let Some(ref next) = Rc::clone(&cur).borrow().next {
-                cur = Rc::clone(next);
-                continue;
-            }
-
-            cur.borrow_mut().next = Some(
-                Rc::new(RefCell::new(node_new))
-            );
-            return;
+        while let Some(ref next) = Rc::clone(&cur).borrow().next {
+            cur = Rc::clone(next);
         }
+
+        cur.borrow_mut().next = Some(
+            Rc::new(RefCell::new(node_new))
+        );
     }
 }
----

[source,rust]
.src/lib.rs
----
use std::fmt;
use std::rc::Rc;
use std::cell::RefCell;

pub struct SinglyLinkedList<T> {
    value: T,
    next: Option<Rc<RefCell<SinglyLinkedList<T>>>>,
}

impl<T: std::fmt::Debug> fmt::Display for SinglyLinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.next {
            None => write!(f, "SinglyLinkedList({:?}, Nil)", self.value),
            Some(ref next) => {
                write!(f, "SinglyLinkedList({:?}, {})", self.value, next.borrow())
            }
        }
    }
}

impl<T> SinglyLinkedList<T> {
    pub fn new(v: T) -> SinglyLinkedList<T> {
        SinglyLinkedList {
            value: v,
            next: None,
        }
    }

    pub fn push_back(&mut self, v: T) {
        let node_new = SinglyLinkedList::new(v);
        let mut cur: Rc<RefCell<SinglyLinkedList<T>>>;
        if let Some(ref next) = self.next {
            cur = Rc::clone(next);
        } else {
            self.next = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            cur = Rc::clone(next);
        }

        cur.borrow_mut().next = Some(
            Rc::new(RefCell::new(node_new))
        );
    }
}
----

[source,rust]
.src/main.rs
----
use list::SinglyLinkedList;

fn main() {
    let mut list = SinglyLinkedList::new();
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);
    println!("{}", list);
}

----

[source,console]
.Results
----
$ cargo run
   Compiling singly-linked-list v0.1.0 (.../singly-linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 2.32s
     Running `.../target/debug/singly-linked-list`
SinglyLinkedList(ListNode(1,ListNode(2,ListNode(3,Nil))))
----

==== v4: Implement pop_back

* First implementation
+
[source,diff]
----
@@ -39,7 +39,7 @@ impl<T: Debug> ListNode<T> {
     }
 }

-impl<T: Debug> SinglyLinkedList<T> {
+impl<T: Debug + Clone> SinglyLinkedList<T> {
     pub fn new() -> SinglyLinkedList<T> {
         SinglyLinkedList {
             head: None,
@@ -64,4 +64,29 @@ impl<T: Debug> SinglyLinkedList<T> {
             Rc::new(RefCell::new(node_new))
         );
     }
+
+    pub fn pop_back(&mut self) -> Option<T> {
+        let mut some_prev: Option<Rc<RefCell<ListNode<T>>>> = None;
+        let mut cur: Rc<RefCell<ListNode<T>>>;
+        if let Some(ref head) = self.head {
+            cur = Rc::clone(head);
+        } else {
+            // You can't pop the head of the list.
+            return None;
+        };
+
+        while let Some(ref next) = Rc::clone(&cur).borrow().next {
+            some_prev = Some(Rc::clone(&cur));
+            cur = Rc::clone(next);
+        }
+
+        let result: T;
+        result = Rc::clone(&cur).borrow().value.clone(); //<2>
+        if let Some(prev) = some_prev {
+            prev.borrow_mut().next = None;
+        } else {
+            self.head = None;
+        }
+        return Some(result);
+    }
 }
----
+
[source,rust]
.src/lib.rs
----
use std::fmt;
use std::fmt::Debug;
use std::rc::Rc;
use std::cell::RefCell;

pub struct ListNode<T: Debug> {
    value: T,
    next: Option<Rc<RefCell<ListNode<T>>>>,
}

pub struct SinglyLinkedList<T: Debug> {
    head: Option<Rc<RefCell<ListNode<T>>>>,
}

impl<T: Debug> fmt::Display for ListNode<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.next {
            None => write!(f, "ListNode({:?},Nil)", self.value),
            Some(ref next) => {
                write!(f, "ListNode({:?},{})", self.value, next.borrow())
            }
        }
    }
}

impl<T: Debug> fmt::Display for SinglyLinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.head {
            None => write!(f, "SinglyLinkedList(Nil)"),
            Some(ref head) => {
                write!(f, "SinglyLinkedList({})", head.borrow())
            }
        }
    }
}

impl<T: Debug> ListNode<T> {
    pub fn new(v: T) -> ListNode<T> {
        ListNode { value: v, next: None }
    }
}

impl<T: Debug + Clone> SinglyLinkedList<T> {  //<1>
    pub fn new() -> SinglyLinkedList<T> {
        SinglyLinkedList {
            head: None,
        }
    }

    pub fn push_back(&mut self, v: T) {
        let node_new = ListNode::new(v);
        let mut cur: Rc<RefCell<ListNode<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            self.head = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            cur = Rc::clone(next);
        }

        cur.borrow_mut().next = Some(
            Rc::new(RefCell::new(node_new))
        );
    }

    pub fn pop_back(&mut self) -> Option<T> {
        let mut some_prev: Option<Rc<RefCell<ListNode<T>>>> = None;
        let mut cur: Rc<RefCell<ListNode<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            // You can't pop the head of the list.
            return None;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            some_prev = Some(Rc::clone(&cur));
            cur = Rc::clone(next);
        }

        let result: T;
        result = Rc::clone(&cur).borrow().value.clone(); //<2>
        if let Some(prev) = some_prev {
            prev.borrow_mut().next = None;
        } else {
            self.head = None;
        }
        return Some(result);
    }
}
----
<1> Clone is required.
<2> Use `value.clone()` to avoid move or copy the value.
+
[source,rust]
.src/main.rs
----
use list::SinglyLinkedList;

fn main() {
    let mut list = SinglyLinkedList::new();
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);
    println!("{}", list);
    assert_eq!(list.pop_back(), Some(3));
    println!("{}", list);
    assert_eq!(list.pop_back(), Some(2));
    println!("{}", list);
    assert_eq!(list.pop_back(), Some(1));
    println!("{}", list);
    assert_eq!(list.pop_back(), None);
    println!("{}", list);
}
----
+
[source,console]
.Results
----
$ cargo run
   Compiling singly-linked-list v0.1.0 (.../singly-linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 2.59s
     Running `.../target/debug/singly-linked-list`
SinglyLinkedList(ListNode(1,ListNode(2,ListNode(3,Nil))))
SinglyLinkedList(ListNode(1,ListNode(2,Nil)))
SinglyLinkedList(ListNode(1,Nil))
SinglyLinkedList(Nil)
SinglyLinkedList(Nil)
----

* Add Drop trait
+
[source,diff]
----
@@ -67,12 +67,14 @@ impl<T: Debug + Clone> SinglyLinkedList<T> {
     }

     pub fn pop_back(&mut self) -> Option<T> {
+        println!("pop_back(): BEGIN");
         let mut some_prev: Option<Rc<RefCell<ListNode<T>>>> = None;
         let mut cur: Rc<RefCell<ListNode<T>>>;
         if let Some(ref head) = self.head {
             cur = Rc::clone(head);
         } else {
             // You can't pop the head of the list.
+            println!("pop_back(): END");
             return None;
         };

@@ -88,6 +90,19 @@ impl<T: Debug + Clone> SinglyLinkedList<T> {
         } else {
             self.head = None;
         }
+        println!("pop_back(): END");
         return Some(result);
     }
 }
+
+impl<T: Debug> Drop for SinglyLinkedList<T> {
+    fn drop(&mut self) {
+        println!("> Dropping: SinglyLinkedList");
+    }
+}
+
+impl<T: Debug> Drop for ListNode<T> {
+    fn drop(&mut self) {
+        println!("> Dropping: {:?}", self.value);
+    }
+}
----
+
[source,rust]
.src/lib.rs
----
use std::fmt;
use std::fmt::Debug;
use std::rc::Rc;
use std::cell::RefCell;

pub struct ListNode<T: Debug> {  //<1>
    value: T,
    next: Option<Rc<RefCell<ListNode<T>>>>,
}

pub struct SinglyLinkedList<T: Debug> {  //<1>
    head: Option<Rc<RefCell<ListNode<T>>>>,
}

impl<T: Debug> fmt::Display for ListNode<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.next {
            None => write!(f, "ListNode({:?},Nil)", self.value),
            Some(ref next) => {
                write!(f, "ListNode({:?},{})", self.value, next.borrow())
            }
        }
    }
}

impl<T: Debug> fmt::Display for SinglyLinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.head {
            None => write!(f, "SinglyLinkedList(Nil)"),
            Some(ref head) => {
                write!(f, "SinglyLinkedList({})", head.borrow())
            }
        }
    }
}

impl<T: Debug> ListNode<T> {
    pub fn new(v: T) -> ListNode<T> {
        ListNode { value: v, next: None }
    }
}

impl<T: Debug + Clone> SinglyLinkedList<T> {
    pub fn new() -> SinglyLinkedList<T> {
        SinglyLinkedList {
            head: None,
        }
    }

    pub fn push_back(&mut self, v: T) {
        let node_new = ListNode::new(v);
        let mut cur: Rc<RefCell<ListNode<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            self.head = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            cur = Rc::clone(next);
        }

        cur.borrow_mut().next = Some(
            Rc::new(RefCell::new(node_new))
        );
    }

    pub fn pop_back(&mut self) -> Option<T> {
        println!("pop_back(): BEGIN");
        let mut some_prev: Option<Rc<RefCell<ListNode<T>>>> = None;
        let mut cur: Rc<RefCell<ListNode<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            // You can't pop the head of the list.
            println!("pop_back(): END");
            return None;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            some_prev = Some(Rc::clone(&cur));
            cur = Rc::clone(next);
        }

        let result: T;
        result = Rc::clone(&cur).borrow().value.clone(); //<2>
        if let Some(prev) = some_prev {
            prev.borrow_mut().next = None;
        } else {
            self.head = None;
        }
        println!("pop_back(): END");
        return Some(result);
    }
}

impl<T: Debug> Drop for SinglyLinkedList<T> {
    fn drop(&mut self) {
        println!("> Dropping: SinglyLinkedList");
    }
}

impl<T: Debug> Drop for ListNode<T> {
    fn drop(&mut self) {
        println!("> Dropping: {:?}", self.value);
    }
}
----
<1> Due to the limitation of the (current) type system, you can't conditionally implement the Drop trait. To add T: Debug bound to the impl Drop, the struct declaration should also have same bound. +
https://users.rust-lang.org/t/drop-impl-requires-t-debug-but-the-struct-it-is-implemented-for-does-not/57763[`Drop` impl requires `T: Debug` but the struct it is implemented for does not - help - The Rust Programming Language Forum^] +
error[E0367]: `Drop` impl requires `T: Debug` but the struct it is implemented for does not - Google 検索
+
[source,rust]
.src/main.rs
----
use list::SinglyLinkedList;

fn main() {
    let mut list = SinglyLinkedList::new();
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);
    println!("{}", list);
    assert_eq!(list.pop_back(), Some(3));
    println!("{}", list);
    assert_eq!(list.pop_back(), Some(2));
    println!("{}", list);
    assert_eq!(list.pop_back(), Some(1));
    println!("{}", list);
    assert_eq!(list.pop_back(), None);
    println!("{}", list);
}
----
+
[source,console]
.Results
----
$ cargo run
   Compiling singly-linked-list v0.1.0 (.../singly-linked-list)
    Finished dev [unoptimized + debuginfo] target(s) in 2.19s
     Running `.../target/debug/singly-linked-list`
SinglyLinkedList(ListNode(1,ListNode(2,ListNode(3,Nil))))
pop_back(): BEGIN
pop_back(): END
> Dropping: 3
SinglyLinkedList(ListNode(1,ListNode(2,Nil)))
pop_back(): BEGIN
pop_back(): END
> Dropping: 2
SinglyLinkedList(ListNode(1,Nil))
pop_back(): BEGIN
pop_back(): END
> Dropping: 1
SinglyLinkedList(Nil)
pop_back(): BEGIN
pop_back(): END
SinglyLinkedList(Nil)
> Dropping: SinglyLinkedList
----

==== v5: Clone is no longer needed with pop_back()

[source,diff]
----
@@ -34,13 +34,13 @@ impl<T: Debug> fmt::Display for SinglyLinkedList<T> {
     }
 }

-impl<T: Clone + Debug> ListNode<T> {
+impl<T: Debug> ListNode<T> {
     pub fn new(v: T) -> ListNode<T> {
         ListNode { value: v, next: None }
     }
 }

-impl<T: Clone + Debug> SinglyLinkedList<T> {
+impl<T: Debug> SinglyLinkedList<T> {
     pub fn new() -> SinglyLinkedList<T> {
         SinglyLinkedList {
             head: None,
@@ -102,13 +102,13 @@ impl<T: Clone + Debug> SinglyLinkedList<T> {
             cur = Rc::clone(next);
         }

-        let result: T;
-        result = Rc::clone(&cur).borrow().value.clone();
         if let Some(prev) = some_prev {
             prev.borrow_mut().next = None;
         } else {
             self.head = None;
         }
+        let result: T;
+        result = Rc::try_unwrap(cur).ok().unwrap().into_inner().value;
         println!("pop_back(): END");
         return Some(result);
     }
----

[source,rust]
.src/lib.rs
----
use std::fmt;
use std::fmt::Debug;
use std::rc::Rc;
use std::cell::RefCell;

pub struct ListNode<T> {
    value: T,
    next: Option<Rc<RefCell<ListNode<T>>>>,
}

pub struct SinglyLinkedList<T> {
    head: Option<Rc<RefCell<ListNode<T>>>>,
}

impl<T: Debug> fmt::Display for ListNode<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.next {
            None => write!(f, "ListNode({:?},Nil)", self.value),
            Some(ref next) => {
                write!(f, "ListNode({:?},{})", self.value, next.borrow())
            }
        }
    }
}

impl<T: Debug> fmt::Display for SinglyLinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.head {
            None => write!(f, "SinglyLinkedList(Nil)"),
            Some(ref head) => {
                write!(f, "SinglyLinkedList({})", head.borrow())
            }
        }
    }
}

impl<T: Debug> ListNode<T> {
    pub fn new(v: T) -> ListNode<T> {
        ListNode { value: v, next: None }
    }
}

impl<T: Debug> SinglyLinkedList<T> {
    pub fn new() -> SinglyLinkedList<T> {
        SinglyLinkedList {
            head: None,
        }
    }

    /// # Examples
    ///
    /// ```
    /// use list::SinglyLinkedList;
    /// let mut list = SinglyLinkedList::new();
    /// list.push_back(1);
    /// list.push_back(2);
    /// ```
    pub fn push_back(&mut self, v: T) {
        let node_new = ListNode::new(v);
        let mut cur: Rc<RefCell<ListNode<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            self.head = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            cur = Rc::clone(next);
        }

        cur.borrow_mut().next = Some(
            Rc::new(RefCell::new(node_new))
        );
    }

    /// # Examples
    ///
    /// ```
    /// use list::SinglyLinkedList;
    /// let mut list = SinglyLinkedList::new();
    /// list.push_back(1);
    /// list.push_back(2);
    /// assert_eq!(list.pop_back(), Some(2));
    /// assert_eq!(list.pop_back(), Some(1));
    /// assert_eq!(list.pop_back(), None);
    /// ```
    pub fn pop_back(&mut self) -> Option<T> {
        println!("pop_back(): BEGIN");
        let mut some_prev: Option<Rc<RefCell<ListNode<T>>>> = None;
        let mut cur: Rc<RefCell<ListNode<T>>>;
        if let Some(ref head) = self.head {
            cur = Rc::clone(head);
        } else {
            // You can't pop the head of the list.
            println!("pop_back(): END");
            return None;
        };

        while let Some(ref next) = Rc::clone(&cur).borrow().next {
            some_prev = Some(Rc::clone(&cur));
            cur = Rc::clone(next);
        }

        if let Some(prev) = some_prev {
            prev.borrow_mut().next = None;
        } else {
            self.head = None;
        }

        let result: T;
        result = Rc::try_unwrap(cur).ok().unwrap().into_inner().value;
        println!("pop_back(): END");
        return Some(result);
    }
}
----

[source,rust]
.src/main.rs
----
use list::SinglyLinkedList;

fn main() {
    let mut list = SinglyLinkedList::new();
    list.push_back(1);
    list.push_back(2);
    list.push_back(3);
    println!("{}", list);
    assert_eq!(list.pop_back(), Some(3));
    println!("{}", list);
    assert_eq!(list.pop_back(), Some(2));
    println!("{}", list);
    assert_eq!(list.pop_back(), Some(1));
    println!("{}", list);
    assert_eq!(list.pop_back(), None);
    println!("{}", list);
}
----

[source,console]
.Results
----
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running `.../target/debug/singly-linked-list`
SinglyLinkedList(ListNode(1,ListNode(2,ListNode(3,Nil))))
pop_back(): BEGIN
pop_back(): END
SinglyLinkedList(ListNode(1,ListNode(2,Nil)))
pop_back(): BEGIN
pop_back(): END
SinglyLinkedList(ListNode(1,Nil))
pop_back(): BEGIN
pop_back(): END
SinglyLinkedList(Nil)
pop_back(): BEGIN
pop_back(): END
SinglyLinkedList(Nil)
----

=== References

* doc.rust-lang.org
** https://doc.rust-lang.org/std/rc/struct.Rc.html[Rc in std::rc - Rust^]
** https://doc.rust-lang.org/std/cell/struct.RefCell.html[RefCell in std::cell - Rust^]
* push_back()
** https://stackoverflow.com/questions/47748091/how-can-i-make-only-certain-struct-fields-mutable[rust - How can I make only certain struct fields mutable? - Stack Overflow^] +
   rust struct mut field - Google Search
** https://stackoverflow.com/questions/55331919/borrowed-refcell-does-not-last-long-enough-when-iterating-over-a-list[rust - Borrowed RefCell does not last long enough when iterating over a list - Stack Overflow^] +
   rust RefCell next list get pointer - Google Search
** https://blog.ymgyt.io/entry/2019/08/17/013313[Rustでdoubly linked list - happy developing^] +
   rust RefCell list next - Google 検索
** https://stackoverflow.com/questions/30243606/why-is-a-borrow-still-held-in-the-else-block-of-an-if-let[rust - Why is a borrow still held in the else block of an if let? - Stack Overflow^] +
   rust borrow else - Google 検索
* pop_front()
** https://rust-unofficial.github.io/too-many-lists/fourth-breaking.html[Breaking - Learning Rust With Entirely Too Many Linked Lists^] +
   rust cannot move out of an rc - Google 検索
** https://stackoverflow.com/questions/66258586/how-can-i-unwrap-an-rc-obtained-by-weakupgrade-having-more-than-one-strong-r[rust - How can I unwrap an Rc, obtained by Weak::upgrade, having more than one strong references? - Stack Overflow^] +
   rust rc into_inner - Google 検索
** https://stackoverflow.com/questions/54012660/unwrap-and-access-t-from-an-optionrcrefcellt[rust - Unwrap and access T from an Option<Rc<RefCell<T>>> - Stack Overflow^] +
   rust rc into_inner - Google 検索
