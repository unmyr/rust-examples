ifndef::leveloffset[]
:toc: left
:toclevels: 3
:icons: font
endif::[]

=== Set up a new project
. Set up a new project, and go to the projects directory.
+
[source,console]
----
$ cargo new --lib singly-linked-list
     Created library `singly-linked-list` package
$ cd singly-linked-list/
----

=== Run

* Using unsafe
+
[source,rust]
.src/lib.rs
----
use std::fmt;
use std::rc::Rc;
use std::cell::RefCell;

pub struct SinglyLinkedList<T> {
    value: T,
    next: Option<Rc<RefCell<SinglyLinkedList<T>>>>,
}

impl<T: std::fmt::Debug> fmt::Display for SinglyLinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.next {
            None => write!(f, "SinglyLinkedList({:?}, Nil)", self.value),
            Some(ref next) => {
                write!(f, "SinglyLinkedList({:?}, {})", self.value, next.borrow())
            }
        }
    }
}

impl<T> SinglyLinkedList<T> {
    pub fn new(v: T) -> SinglyLinkedList<T> {
        SinglyLinkedList {
            value: v,
            next: None,
        }
    }
    pub fn push_back(&mut self, v: T) {
        let node_new = SinglyLinkedList::new(v);

        let mut cur: Option<Rc<RefCell<SinglyLinkedList<T>>>>;
        if let Some(ref next) = self.next {
            cur = Some(Rc::clone(next));
        } else {
            self.next = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        loop {
            let cur_cloned = match cur {
                None => break,
                Some(ref n) => Rc::clone(n)
            };
            cur = match cur_cloned.borrow().next {
                Some(ref next) => Some(Rc::clone(next)),
                None => {
                    unsafe {
                        (*cur_cloned.as_ptr()).next = Some(
                            Rc::new(
                                RefCell::new(node_new)
                            )
                        );
                    }
                    return;
                }
            };
        }
    }
}
----
+
[source,rust]
.src/main.rs
----
use list::SinglyLinkedList;

fn main() {
    let mut list = SinglyLinkedList::new(1);
    list.push_back(2);
    list.push_back(3);
    println!("{}", list);
}
----
+
[source,console]
.Results
----
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running `.../target/debug/singly-linked-list`
SinglyLinkedList(1, SinglyLinkedList(2, SinglyLinkedList(3, Nil)))
----

* Remove unsafe
+
[source,rust]
----
use std::fmt;
use std::rc::Rc;
use std::cell::RefCell;

pub struct SinglyLinkedList<T> {
    value: T,
    next: Option<Rc<RefCell<SinglyLinkedList<T>>>>,
}

impl<T: std::fmt::Debug> fmt::Display for SinglyLinkedList<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.next {
            None => write!(f, "SinglyLinkedList({:?}, Nil)", self.value),
            Some(ref next) => {
                write!(f, "SinglyLinkedList({:?}, {})", self.value, next.borrow())
            }
        }
    }
}

impl<T> SinglyLinkedList<T> {
    pub fn new(v: T) -> SinglyLinkedList<T> {
        SinglyLinkedList {
            value: v,
            next: None,
        }
    }

    pub fn push_back(&mut self, v: T) {
        let node_new = SinglyLinkedList::new(v);
        let mut cur: Rc<RefCell<SinglyLinkedList<T>>>;
        if let Some(ref next) = self.next {
            cur = Rc::clone(next);  //<1>
        } else {
            self.next = Some(Rc::new(RefCell::new(node_new)));
            return;
        };

        loop {
            if let Some(ref next) = Rc::clone(&cur).borrow().next {  //<1>
                cur = Rc::clone(next);  //<1>
                continue;
            } // <2>

            cur.borrow_mut().next = Some(
                Rc::new(RefCell::new(node_new))
            );
            return;
        }
    }
}
----
<1> Use `Rc::clone()` to avoid move the pointer.
<2> The `cur` is still borrowed in the if-else and `match` block.
+
[source,rust]
.src/main.rs
----
use list::SinglyLinkedList;

fn main() {
    let mut list = SinglyLinkedList::new(1);
    list.push_back(2);
    list.push_back(3);
    println!("{}", list);
}
----
+
[source,console]
.Results
----
$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running `.../target/debug/singly-linked-list`
SinglyLinkedList(1, SinglyLinkedList(2, SinglyLinkedList(3, Nil)))
----

=== References

* doc.rust-lang.org
** https://doc.rust-lang.org/std/rc/struct.Rc.html[Rc in std::rc - Rust^]
** https://doc.rust-lang.org/std/cell/struct.RefCell.html[RefCell in std::cell - Rust^]
* https://stackoverflow.com/questions/47748091/how-can-i-make-only-certain-struct-fields-mutable[rust - How can I make only certain struct fields mutable? - Stack Overflow^] +
  rust struct mut field - Google Search
* https://stackoverflow.com/questions/55331919/borrowed-refcell-does-not-last-long-enough-when-iterating-over-a-list[rust - Borrowed RefCell does not last long enough when iterating over a list - Stack Overflow^] +
  rust RefCell next list get pointer - Google Search
* https://blog.ymgyt.io/entry/2019/08/17/013313[Rustでdoubly linked list - happy developing^] +
  rust RefCell list next - Google 検索
* https://stackoverflow.com/questions/30243606/why-is-a-borrow-still-held-in-the-else-block-of-an-if-let[rust - Why is a borrow still held in the else block of an if let? - Stack Overflow^] +
  rust borrow else - Google 検索
