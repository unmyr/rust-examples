== Accepting Command Line Arguments

* https://doc.rust-lang.org/book/ch12-01-accepting-command-line-arguments.html[Accepting Command Line Arguments - The Rust Programming Language^]

=== Set up a new project
. Set up a new project, and go to the projects directory.
+
[source,console]
----
$ cargo new --bin minigrep
     Created binary (application) `minigrep` package
$ cd minigrep/
----

=== Reading the Argument Values

[source,rust]
.src/main.rs
----
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{:?}", args);
}
----

[source,console]
----
minigrep$ cargo run example-filename.txt
   Compiling minigrep v0.1.0 (<path-to-project>/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.92s
     Running `target/debug/minigrep example-filename.txt`
["target/debug/minigrep", "example-filename.txt"]
----

=== Saving the Argument Values in Variables
[source,rust]
.src/main.rs
----
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let filename = &args[2];

    println!("Searching for {}", query);
    println!("In file {}", filename);
}
----

[source,console]
----
$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
----

== Reading a File
* https://doc.rust-lang.org/book/ch12-02-reading-a-file.html[Reading a File - The Rust Programming Language^]

ifdef::env-github,backend-html5[]
.poem.txt
----
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
----
endif::[]

ifndef::env-github,backend-html5[]
.poem.txt
----
include::poem.txt[]
----
endif::[]


=== Reading the contents of the file specified by the second argument
[source,diff]
.src/main.rs
----
@@ -1,4 +1,5 @@
 use std::env;
+use std::fs;

 fn main() {
     let args: Vec<String> = env::args().collect();
@@ -8,4 +9,9 @@ fn main() {

     println!("Searching for {}", query);
     println!("In file {}", filename);
+
+    let contents = fs::read_to_string(filename)
+        .expect("Something went wrong reading the file");
+
+    println!("With text:\n{}", contents);
 }
----

[source,console]
----
minigrep$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (<path-to-project>/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.97s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
----

== Refactoring to Improve Modularity and Error Handling
* https://doc.rust-lang.org/book/ch12-03-improving-error-handling-and-modularity.html[Refactoring to Improve Modularity and Error Handling - The Rust Programming Language^]


=== Extracting the Argument Parser

==== Extracting a `parse_config` function from `main`
[source,diff]
.src/main.rs
----
@@ -4,8 +4,7 @@ use std::fs;
 fn main() {
     let args: Vec<String> = env::args().collect();

-    let query = &args[1];
-    let filename = &args[2];
+    let (query, filename) = parse_config(&args);

     println!("Searching for {}", query);
     println!("In file {}", filename);
@@ -15,3 +14,10 @@ fn main() {

     println!("With text:\n{}", contents);
 }
+
+fn parse_config(args: &[String]) -> (&str, &str) {
+    let query = &args[1];
+    let filename = &args[2];
+
+    (query, filename)
+}
----

[%collapsible]
.src/main.rs
====
[source,rust]
----
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();

    let (query, filename) = parse_config(&args);

    println!("Searching for {}", query);
    println!("In file {}", filename);

    let contents = fs::read_to_string(filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

fn parse_config(args: &[String]) -> (&str, &str) {
    let query = &args[1];
    let filename = &args[2];

    (query, filename)
}
----
====

[source,console]
----
minigrep$ cargo run test poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/minigrep test poem.txt`
Searching for test
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
----

=== Grouping Configuration Values

==== Refactoring parse_config to return an instance of a Config struct

[source,diff]
.src/main.rs
----
@@ -4,20 +4,25 @@ use std::fs;
 fn main() {
     let args: Vec<String> = env::args().collect();

-    let (query, filename) = parse_config(&args);
+    let config = parse_config(&args);

-    println!("Searching for {}", query);
-    println!("In file {}", filename);
+    println!("Searching for {}", config.query);
+    println!("In file {}", config.filename);

-    let contents = fs::read_to_string(filename)
+    let contents = fs::read_to_string(config.filename)
         .expect("Something went wrong reading the file");

     println!("With text:\n{}", contents);
 }

-fn parse_config(args: &[String]) -> (&str, &str) {
-    let query = &args[1];
-    let filename = &args[2];
+struct Config {
+    query: String,
+    filename: String,
+}
+
+fn parse_config(args: &[String]) -> Config {
+    let query = args[1].clone();
+    let filename = args[2].clone();

-    (query, filename)
+    Config { query, filename }
 }
----

[source,rust]
.src/main.rs
----
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = parse_config(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &[String]) -> Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
----

=== Creating a Constructor for Config

[source,diff]
----
@@ -4,7 +4,7 @@ use std::fs;
 fn main() {
     let args: Vec<String> = env::args().collect();

-    let config = parse_config(&args);
+    let config = Config::new(&args);

     println!("Searching for {}", config.query);
     println!("In file {}", config.filename);
@@ -20,9 +20,11 @@ struct Config {
     filename: String,
 }

-fn parse_config(args: &[String]) -> Config {
-    let query = args[1].clone();
-    let filename = args[2].clone();
+impl Config {
+    fn new(args: &[String]) -> Config {
+        let query = args[1].clone();
+        let filename = args[2].clone();

-    Config { query, filename }
+        Config { query, filename }
+    }
 }
----

[source,rust]
----
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

struct Config {
    query: String,
    filename: String,
}

impl Config {
    fn new(args: &[String]) -> Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
----

[source,console]
----
$ cargo run test poem.txt
   Compiling minigrep v0.1.0 (<path-to-project>/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.99s
     Running `target/debug/minigrep test poem.txt`
Searching for test
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
----

=== Fixing the Error Handling

[source,console]
.thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1'
----
minigrep$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:25:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
----

==== Adding a check for the number of arguments

[source,diff]
.src/main.rs
----
@@ -22,6 +22,9 @@ struct Config {

 impl Config {
     fn new(args: &[String]) -> Config {
+        if args.len() < 3 {
+            panic!("not enough arguments");
+        }
         let query = args[1].clone();
         let filename = args[2].clone();
----

[source,console]
.thread 'main' panicked at 'not enough arguments'
----
minigrep$ cargo run
   Compiling minigrep v0.1.0 (<path-to-project>/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 2.17s
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
----

=== Returning a Result from new Instead of Calling panic!

[source,diff]
.src/main.rs
----
@@ -21,13 +21,14 @@ struct Config {
 }

 impl Config {
-    fn new(args: &[String]) -> Config {
+    fn new(args: &[String]) -> Result<Config, &str> {
         if args.len() < 3 {
-            panic!("not enough arguments");
+            return Err("not enough arguments");
         }
+
         let query = args[1].clone();
         let filename = args[2].clone();

-        Config { query, filename }
+        Ok(Config { query, filename })
     }
 }
----

=== Calling Config::new and Handling Errors

==== Exiting with an error code if creating a new `Config` fails
[source,rust]
.src/main.rs
----
use std::env;
use std::fs;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

struct Config {
    query: String,
    filename: String,
}

impl Config {
    fn new(args: &[String]) -> Result<Config, &str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
----

[source,console]
----
minigrep$ cargo run
   Compiling minigrep v0.1.0 (<path-to-project>/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 2.08s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
----

=== Extracting Logic from `main`

==== Extracting a `run` function containing the rest of the program logic
[source,rust]
.src/main.rs
----
use std::env;
use std::fs;
use std::process;

fn main() {
    // --snip--

    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

// --snip--

struct Config {
    query: String,
    filename: String,
}

impl Config {
    fn new(args: &[String]) -> Result<Config, &str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
----

=== Returning Errors from the run Function

==== Changing the `run` function to return `Result`
[source,diff]
----
@@ -1,6 +1,7 @@
 use std::env;
 use std::fs;
 use std::process;
+use std::error::Error;

 fn main() {
     let args: Vec<String> = env::args().collect();
@@ -16,11 +17,12 @@ fn main() {
     run(config);
 }

-fn run(config: Config) {
-    let contents = fs::read_to_string(config.filename)
-        .expect("Something went wrong reading the file");
+fn run(config: Config) -> Result<(), Box<dyn Error>> {
+    let contents = fs::read_to_string(config.filename)?;

     println!("With text:\n{}", contents);
+
+    Ok(())
 }
----

[source,rust]
.src/main.rs
----
use std::error::Error;

// --snip--

fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    println!("With text:\n{}", contents);

    Ok(())
}
----
When you run this code, it will compile but will display a warning:

[source,console]
----
minigrep$ cargo run the poem.txt
warning: unused `std::result::Result` that must be used
  --> src/main.rs:17:5
   |
17 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: 1 warning emitted

    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
----

=== Handling Errors Returned from run in main

[source,diff]
.src/main.rs
----
@@ -14,7 +14,11 @@ fn main() {
     println!("Searching for {}", config.query);
     println!("In file {}", config.filename);

-    run(config);
+    if let Err(e) = run(config) {
+        println!("Application error: {}", e);
+
+        process::exit(1);
+    }
 }

 fn run(config: Config) -> Result<(), Box<dyn Error>> {
----