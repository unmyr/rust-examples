== Description

* https://doc.rust-lang.org/book/ch20-01-single-threaded.html[Building a Single-Threaded Web Server - The Rust Programming Language^]

=== Create

. Letâ€™s create a new library project called `deref_example`
+
[source,console]
----
$ cargo new hello
     Created binary (application) `hello` project
$ cd hello/
----

=== Building a Single-Threaded Web Server

==== Listening to the TCP Connection

===== Listing 20-1: Listening for incoming streams and printing a message when we receive a stream

[source,rust]
.Filename: src/main.rs
----
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        #[allow(unused_variables)]
        let stream = stream.unwrap();

        println!("Connection established!");
    }
}
----

[source,console]
----
$ cargo run
   Compiling hello v0.1.0 (<path-to-project>/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 3.34s
     Running `target/debug/hello`
Connection established!
Connection established!
^C
----

[source,console]
----
$ curl 127.0.0.1:7878
curl: (52) Empty reply from server
$ curl 127.0.0.1:7878
curl: (52) Empty reply from server
----

==== Reading the Request

===== Listing 20-2: Reading from the TcpStream and printing the data

[source,diff]
.git diff src/main.rs
----
@@ -1,12 +1,21 @@
+use std::io::prelude::*;
 use std::net::TcpListener;
+use std::net::TcpStream;

 fn main() {
     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

     for stream in listener.incoming() {
-        #[allow(unused_variables)]
         let stream = stream.unwrap();

-        println!("Connection established!");
+        handle_connection(stream);
     }
 }
+
+fn handle_connection(mut stream: TcpStream) {
+    let mut buffer = [0; 1024];
+
+    stream.read(&mut buffer).unwrap();
+
+    println!("Request: {}", String::from_utf8_lossy(&buffer[..]));
+}
----

[source,rust]
.Filename: src/main.rs
----
use std::io::prelude::*; // <1>
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&mut buffer).unwrap();

    println!("Request: {}", String::from_utf8_lossy(&buffer[..]));
}
----
<1> We bring std::io::prelude into scope to get access to certain traits that let us read from and write to the stream.

[source,console]
----
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: curl/7.58.0
Accept: */*



----

[source,console]
----
$ curl 127.0.0.1:7878
curl: (52) Empty reply from server
----

==== A Closer Look at an HTTP Request

===== Listing 20-3: Writing a tiny successful HTTP response to the stream


[source,diff]
.git diff src/main.rs
----
@@ -17,5 +17,8 @@ fn handle_connection(mut stream: TcpStream) {

     stream.read(&mut buffer).unwrap();

-    println!("Request: {}", String::from_utf8_lossy(&buffer[..]));
+    let response = "HTTP/1.1 200 OK\r\n\r\n";
+
+    stream.write(response.as_bytes()).unwrap();
+    stream.flush().unwrap();
 }
----

[source,rust]
.Filename: src/main.rs
----
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&mut buffer).unwrap();

    let response = "HTTP/1.1 200 OK\r\n\r\n";

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
----

[source,console]
----
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/hello`
^C
----

[source,console]
----
$ curl --verbose 127.0.0.1:7878
* Rebuilt URL to: 127.0.0.1:7878/
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to 127.0.0.1 (127.0.0.1) port 7878 (#0)
> GET / HTTP/1.1
> Host: 127.0.0.1:7878
> User-Agent: curl/7.58.0
> Accept: */*
>
< HTTP/1.1 200 OK
* no chunk, no close, no size. Assume close to signal end
<
* Closing connection 0
----

==== Returning Real HTML

===== Listing 20-4: A sample HTML file to return in a response

[source,html]
.Filename: hello.html
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1>Hello!</h1>
    <p>Hi from Rust</p>
  </body>
</html>
----

===== Listing 20-5: Sending the contents of hello.html as the body of the response

[source,diff]
.git diff src/main.rs
----
@@ -1,6 +1,7 @@
 use std::io::prelude::*;
 use std::net::TcpListener;
 use std::net::TcpStream;
+use std::fs;

 fn main() {
     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
@@ -14,10 +15,15 @@ fn main() {

 fn handle_connection(mut stream: TcpStream) {
     let mut buffer = [0; 1024];
-
     stream.read(&mut buffer).unwrap();

-    let response = "HTTP/1.1 200 OK\r\n\r\n";
+    let contents = fs::read_to_string("hello.html").unwrap();
+
+    let response = format!(
+        "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
+        contents.len(),
+        contents
+    );

     stream.write(response.as_bytes()).unwrap();
     stream.flush().unwrap();
----

[%collapsible]
.Filename: src/main.rs
====
[source,rust]
----
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::fs;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&mut buffer).unwrap();

    let contents = fs::read_to_string("hello.html").unwrap();

    let response = format!(
        "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
----
====

[source,console]
----
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/hello`
^C
----

[source,console]
----
$ curl 127.0.0.1:7878
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hello!</title>
  </head>
  <body>
    <h1>Hello!</h1>
    <p>Hi from Rust</p>
  </body>
</html>
----